#!/usr/bin/env python
# -*- coding: utf-8 -*-
from scipy.spatial import distance
from math import log
from Config import CLASSES

from FeatureExtraction import _extract_train_programs_features
from FeatureExtraction import _extract_program_features
from FeatureExtraction import _get_all_functs
from FeatureExtraction import _get_func_model
from FeatureExtraction import _get_vectors_information
from FeatureExtraction import _train_w2v_model
from FeatureExtraction import _get_program_representation
from Utils import _serialize
from Utils import _unserialize
import logging


def _program_distance(p1,p2,f=distance.correlation):  
	""" 

		Devuelve la log-verosimilitud de las representaciones

		Parámetros:
		p1        		   -- Representacion vectorial del programa 1 (combinado de instrucciones, funciones y medida de empaquetamiento)
		p2                 -- Representacion vectorial del programa 1 (combinado de instrucciones, funciones y medida de empaquetamiento)
   
		Excepciones:
		A implementar
    """
	d = f(p1,p2)
	return log(d) if d>0 else d
	
def _get_k_most_similar_program(p1,programs,model,k):
	""" Determina los k programas más semejantes "semánticamente" a un programa p1 dado

		Devuelve 0 si el programa no es malware y 1 en caso contrario

		Parámetros:
		p1        		   -- Representación vectorial completa del programa p1.
		programs  		   -- Representaciones vectoriales de los prototipos.
		model			   -- Modelo word2vec.
		k                  -- Número de vecinos a emplear en la clasificación.

		Excepciones:
		A implementar
    """
	k_similar_programs = []
	for i in xrange(len(programs)):
		program 		  = programs[i][0]
		cat				  = programs[i][1]
		if len(p1)>0 and len(program)>0 and program!=['']:
			m = _program_distance(p1,program)
			if len(k_similar_programs)!=k: k_similar_programs.append((m,program,cat))
			else:
				max_k_similar_programs = max(k_similar_programs)
				if m<max_k_similar_programs[0]:
					k_similar_programs[k_similar_programs.index(max_k_similar_programs)] = ((m,program,cat))
	return k_similar_programs

def _get_class(p1,programs,model,k):
	""" Determina la clase de un programa p1 dado

    Devuelve 0 si el programa no es malware y 1 en caso contrario

    Parámetros:
    p1        		   -- Representación vectorial completa del programa p1.
    programs  		   -- Representaciones vectoriales de los prototipos.
    model			   -- Modelo word2vec.
    k                  -- Número de vecinos a emplear en la clasificación.

    Excepciones:
    A implementar
    """
	k_similar_programs = _get_k_most_similar_program(p1,programs,model,k)
	h,m,c_class = {},0,-1
	if not k_similar_programs: return None
	else:
		for (distance,program,cat) in k_similar_programs:
			if cat not in h: h[cat]  = 1
			else:			 h[cat] += 1
			if h[cat]>m: m,c_class = h[cat],cat
		return c_class
		

	
def _fit(malware_files,non_malware_files,save=True,fprototypes="./train_prototypes.trained",fmodel="./modelw2v.mm",ffunctions="./modelfuncts.mm"): 
	""" Entrena el sistema. Obtiene el modelo word2vec, el modelo de funciones (funciones llamadas por las muestras supervisadas) y
		con ello genera los prototipos.

		Si se indica, almacena en ficheros separados el modelo word2vec, el modelo de funciones y los prototipos, si no
		simplemente los devuelve en una tupla 3-d.
    
		Parámetros:
		train_malware	     -- Ruta donde se encuentran las muestras malware supervisadas.
		train_non_malware    -- Ruta donde se encuentran las muestras no malware supervisadas.
		save			  	 -- Indica si se quieren almacenar los resultados del entrenamiento.
		fprototypes	  	 -- Ruta donde almacenar los prototipos
		fmodel			  	 -- Ruta donde almacenar el modelo word2vec
		ffunctions		  	 -- Ruta donde almacenar el modelo de funciones
		
		Excepciones:
		A implementar.
    
    """
	logging.basicConfig(format='%(asctime)s : %(levelname)s : %(message)s', level=logging.INFO)
	logging.info("Initializing training with: "+str(len(malware_files)+len(non_malware_files))+" files")
	file_features                 = _extract_train_programs_features(malware_files,non_malware_files)
	func_features				  = _get_all_functs(file_features)
	ffmodel                       =  _get_func_model(file_features,func_features)
	programs,dll_functs,is_packed = _get_vectors_information(file_features,ffmodel)
	model 						  = _train_w2v_model(programs)
	prototypes                    = [(_get_program_representation(programs[i][0],model).tolist()+dll_functs[i]+[is_packed[i]],programs[i][1]) for i in xrange(len(programs))]
	if save==True:
		_serialize(fprototypes,prototypes)
		_serialize(fmodel,model)
		_serialize(ffunctions,func_features)
		logging.info("Saved training results. ")
	else: return (prototypes,model,func_features)
	
def _predict(file_name,k,load=True,prototypes=None,model=None,fmodel=None,fprototypes="./train_prototypes.trained",fw2vmodel="./modelw2v.mm",ffmodel="./modelfuncts.mm"):
	""" Clasifica un programa cuya ruta es file_name.

		Devuelve la clasificación del programa: malware o no malware.
    
		Parámetros:
		file_name	  -- Nombre del programa a clasificar
		k             -- Número de vecinos más cercanos.
		load		  -- Indica si se van a cargar los datos de entrenamiento desde fichero o se reciben de la función train.
		prototypes    -- Conjunto de prototipos (muestras supervisadas) obtenidos del entrenamiento.
		model         -- Modelo Word2Vec previamente entrenado.
		fmode		  -- Modelo de funciones (todas las funciones extraidas del conjunto de entrenamiento)
		fprototypes   -- Ruta donde se encuentran los prototipos (muestras supervisadas)
		fw2vmodel	  -- Ruta donde se encuentra el modelo Word2Vec entrenado.
		ffmodel		  -- Ruta donde se encuentra el fichero con todas las funciones llamadas por los prototipos
		
		Excepciones:
		A implementar.
    
    """
	if load==True:
		prototypes = _unserialize(fprototypes)[0]
		model	   = _unserialize(fw2vmodel)[0]
		fmodel	   = list(_unserialize(ffmodel)[0])
	exe_instructions,imports,is_packed = _extract_program_features(file_name)
	file_features = {}
	file_features[file_name] = [(exe_instructions,None),imports,is_packed]
	func_features = _get_func_model(file_features,fmodel)
	exe_instructions,imports,is_packed = _get_vectors_information(file_features,func_features)
	exe_instructions,imports,is_packed = exe_instructions[0][0],imports[0],is_packed
	test_sample = [_get_program_representation(exe_instructions,model).tolist()+imports+is_packed]
	return CLASSES[_get_class(test_sample,prototypes,model,k)]
	
