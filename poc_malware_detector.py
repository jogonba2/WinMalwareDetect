#!/usr/bin/env python
# -*- coding: utf-8 -*-

from pefile import PE
from pydasm import get_instruction,get_instruction_string,MODE_32,FORMAT_INTEL
from os import walk
from gensim.models import Word2Vec
from scipy.spatial import distance
from math import log,sqrt
import logging
try: from cPickle import dump,load,HIGHEST_PROTOCOL
except: from pickle import dump,load,HIGHEST_PROTOCOL

## Model parameters ##
MIN_COUNT=5
SIZE=350
WINDOW=1
CLASSES = {0:"No malware",1:"Malware"}
# ... #

##########################
def _get_imports(pe): 
	""" Extrae las funciones de las que hace uso el programa. 
		Devuelve el conjunto de funciones.

		Parámetros:
		pe      		   -- Objeto de pefile con el programa abierto.

		Excepciones:
		A implementar
    """
	imports = []
	for entry in pe.DIRECTORY_ENTRY_IMPORT:
		for imp in entry.imports: imports.append(imp.name)
	return imports

def _is_packed(pe):
	""" Extrae la medida de empaquetamiento del programa. 
		Para tener una medida que permita determinar si un programa está empaquetado se tiene en cuenta actualmente:
		  · Entropía
		  · UPX
		  · ASPACK
		Devuelve la medida de empaquetamiento que se define como:
		sqrt(entropia^2 + {1 si hay una sección upx, 0 e.c.o.c}^2 + {1 si hay una sección aspack, 0 e.c.o.c}^2)

		Parámetros:
		pe      		   -- Objeto de pefile con el programa abierto.

		Excepciones:
		A implementar
    """
	def _entropy():  return sum([sec.get_entropy() for sec in pe.sections])
			
	def _upx():     
		for section in pe.sections:
			if "upx" in section.Name.lower(): return 1
		return 0
		
	def _aspack(): 
		for section in pe.sections:
			if "aspack" in section.Name.lower(): return 1
		return 0
	
	return sqrt(_entropy()**2+_upx()**2+_aspack()**2)
	
def _get_instructions(pe):
	""" Extrae la representación textual de las instrucciones del programa
	
		Devuelve el conjunto de instrucciones. 

		Parámetros:
		pe      		   -- Objeto de pefile con el programa abierto.

		Excepciones:
		A implementar
    """
	entry_point = pe.OPTIONAL_HEADER.AddressOfEntryPoint
	ep_ava = entry_point
	data = pe.get_memory_mapped_image()[entry_point:entry_point+pe.OPTIONAL_HEADER.SizeOfCode]
	offset,instructions = 0,set()
	while offset<len(data):
		instruction = get_instruction(data[offset:],MODE_32)
		if instruction==None: break
		else:
			instructions.add(get_instruction_string(instruction,FORMAT_INTEL,ep_ava+offset))
			offset += instruction.length
	return list(instructions)

def _get_ngrams(instructions,ngrams):
	""" Obtiene el conjunto de ngramas dada una lista de instrucciones
	
		Devuelve el conjunto de ngramas

		Parámetros:
		pe      		   -- Objeto de pefile con el programa abierto.

		Excepciones:
		A implementar
    """
	ngrams = set()
	for i in xrange(len(instructions)-NGRAMS-1): ngrams.add(tuple(instructions[i:i+4]))
	return list(ngrams)

def _get_files(path):
	""" Obtiene la ruta absoluta de los ficheros de un directorio
	
		Devuelve de rutas absolutas.

		Parámetros:
		pe      		   -- Objeto de pefile con el programa abierto.

		Excepciones:
		A implementar
    """
	res = []
	for root,dirs,files in walk(path):
		for fd in files: res.append(root+"/"+fd)
	return res

def _extract_program_features(file_name):
	""" Extrae la información de un programa dado

		La información que se extrae actualmente son el conjunto de instrucciones, las funciones y una medida de empaquetamiento

		Parámetros:
		file_name      		   -- Ruta del programa

		Excepciones:
		A implementar
    """
    
	pe                     = PE(file_name)
	exe_instructions,imports,is_packed       = _get_instructions(pe),set(_get_imports(pe)),_is_packed(pe)
	return exe_instructions,imports,is_packed
	
def _extract_train_programs_features(malware_files,non_malware_files):
	""" Obtiene la información de las muestras de entrenamiento (prototipos) 

		La información que se extrae actualmente son el conjunto de instrucciones, las funciones y una medida de empaquetamiento
		Devuelve un diccionario {nombreDePrograma:[(instrucciones,clase),(funciones),(medidaEmpaquetamiento)],...}
		

		Parámetros:
		malware_files       		   -- Directorio donde se encuentran las muestras de entrenamiento malware.
		non_malware_files 			   -- Directorio donde se encuentran las muestras de entrenamiento no malware.

		Excepciones:
		A implementar
    """
	file_features           = {}
	i = 0
	for non_malware_file in non_malware_files:
		logging.info("Extracting information from file "+str(i)+" : "+non_malware_file)
		exe_instructions,imports,is_packed = _extract_program_features(non_malware_file)
		file_features[non_malware_file] = [(exe_instructions,0),imports,is_packed]
		i += 1
	
	for malware_file in malware_files:
		logging.info("Extracting information from file "+str(i)+" : "+malware_file)
		exe_instructions,imports,is_packed = _extract_program_features(malware_file)
		file_features[malware_file] = [(exe_instructions,1),imports,is_packed]
		i += 1
		
	logging.info("Instructions and functions extracted from all programs and detected if they're packed")
	
	return file_features	

def _get_program_representation(p,model):
	""" Genera la representación vectorial de las instrucciones del programa p en base al modelo w2v previamente entrenado

		Devuelve la representación vectorial de las instrucciones del programa p.
		Se define la representación vectorial de un conjunto de instrucciones como la suma de las representaciones
		vectoriales de cada instrucción del conjunto (suma de semánticas)

		Parámetros:
		p       		   -- Conjunto de instrucciones del programa p.
		model 			   -- Modelo word2vec ya entrenado.

		Excepciones:
		A implementar
    """
	try:     res = 0 + model[p[0]]
	except:  res = 0
	for i in xrange(1,len(p)):
		try: 	res += model[p[i]]
		except: res += 0
	return res

def _program_distance(p1,p2,f=distance.correlation):  
	""" 

		Devuelve la log-verosimilitud de las representaciones

		Parámetros:
		p1        		   -- Representacion vectorial del programa 1 (combinado de instrucciones, funciones y medida de empaquetamiento)
		p2                 -- Representacion vectorial del programa 1 (combinado de instrucciones, funciones y medida de empaquetamiento)
   
		Excepciones:
		A implementar
    """
	d = f(p1,p2)
	return log(d) if d>0 else d

def _get_k_most_similar_program(p1,programs,model,k):
	""" Determina los k programas más semejantes "semánticamente" a un programa p1 dado

		Devuelve 0 si el programa no es malware y 1 en caso contrario

		Parámetros:
		p1        		   -- Representación vectorial completa del programa p1.
		programs  		   -- Representaciones vectoriales de los prototipos.
		model			   -- Modelo word2vec.
		k                  -- Número de vecinos a emplear en la clasificación.

		Excepciones:
		A implementar
    """
	k_similar_programs = []
	for i in xrange(len(programs)):
		program 		  = programs[i][0]
		cat				  = programs[i][1]
		if len(p1)>0 and len(program)>0 and program!=['']:
			m = _program_distance(p1,program)
			if len(k_similar_programs)!=k: k_similar_programs.append((m,program,cat))
			else:
				max_k_similar_programs = max(k_similar_programs)
				if m<max_k_similar_programs[0]:
					k_similar_programs[k_similar_programs.index(max_k_similar_programs)] = ((m,program,cat))
	return k_similar_programs

def _get_class(p1,programs,model,k):
	""" Determina la clase de un programa p1 dado

    Devuelve 0 si el programa no es malware y 1 en caso contrario

    Parámetros:
    p1        		   -- Representación vectorial completa del programa p1.
    programs  		   -- Representaciones vectoriales de los prototipos.
    model			   -- Modelo word2vec.
    k                  -- Número de vecinos a emplear en la clasificación.

    Excepciones:
    A implementar
    """
	k_similar_programs = _get_k_most_similar_program(p1,programs,model,k)
	h,m,c_class = {},0,-1
	if not k_similar_programs: return None
	else:
		for (distance,program,cat) in k_similar_programs:
			if cat not in h: h[cat]  = 1
			else:			 h[cat] += 1
			if h[cat]>m: m,c_class = h[cat],cat
		return c_class

def _train_w2v_model(corpus_programs): 
	""" Entrena un modelo word2vec sobre el conjunto de instrucciones de los programas

		Devuelve el modelo entrenado.
    
		Parámetros:
		corpus_programs -- Conjunto de tuplas con las instrucciones de los programas y sus categorias (instrucciones,categoria)

		Excepciones:
		A implementar.
    
    """
	return Word2Vec([program for (program,cat) in corpus_programs],min_count=MIN_COUNT,size=SIZE,window=WINDOW)


def _get_all_functs(file_features):
	func_features = set()
	for fd in file_features: func_features = func_features.union(file_features[fd][1])
	return func_features
	
def _get_func_model(file_features,func_features):
	""" Genera para cada programa un vector BOW sobre sus funciones: 1 si tiene una llamada a una función f, 0 si no
		
		Devuelve el conjunto de vectores BOW de todos los programas.
	
		Parámetros:
		file_features -- Diccionario con tantas entradas como programas, para cada programa se almacena información (cjto de instrucciones,funciones y medida de empaquetamiento)

		Excepciones:
		A implementar.   
    """
	res = []

	for fd in file_features:
		fd_features = []
		for feature in func_features:
			if feature in file_features[fd][1]: fd_features.append(1)
			else:								fd_features.append(0)
		res.append(fd_features)
		
	return res

def _get_vectors_information(file_features,ffmodel):
	""" Genera N vectores con el conjunto P de programas , F de funciones y otra información
		
		Devuelve los N vectores con información sobre todo el conjunto de prototipos. 
	
		Parámetros:
		file_features -- Diccionario con tantas entradas como programas, para cada programa se almacena información (cjto de instrucciones,funciones y medida de empaquetamiento)
		func_features -- Conjunto de funciones presentes en el corpus de entrenamiento
		Excepciones:
		A implementar.   
    """
	programs,dll_functs,is_packed           = [],[],[]
	keys = file_features.keys()
	for i in xrange(len(keys)):
		feature = keys[i]
		programs.append(file_features[feature][0])
		dll_functs.append(ffmodel[i])
		is_packed.append(file_features[feature][2])
	return programs,dll_functs,is_packed
	
def _cross_validation(train_malware_path,train_non_malware_path,k,beta=1):
	""" Realiza validación cruzada (leaving one out) sobre el conjunto de entrenamiento.

		Muestra por pantalla el conjunto de medidas de evaluación del sistema.
    
		Parámetros:
		file_features -- Diccionario con tantas entradas como programas, para cada programa se almacena información (cjto de instrucciones,funciones y medida de empaquetamiento)
		k             -- Número de vecinos más cercanos.
		beta          -- Parámetro beta para calcular la f-medida (1 si se pondera igual la precisión que el recall).
		Excepciones:
		A implementar.
    
    """
	malware_files                     = _get_files(train_malware_path)
	non_malware_files                 = _get_files(train_non_malware_path)
	num_programs					  = len(malware_files)+len(non_malware_files)
	act_index,act_test_sample,err = 0,None,0
	tp,tn,fp,fn,tpr,spc,ppv,npv,fpr,fnr,fdr,acc,fscore = 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
	file_features                 = _extract_train_programs_features(malware_files,non_malware_files)
	func_features				  = _get_all_functs(file_features)
	ffmodel                       =  _get_func_model(file_features,func_features)
	programs,dll_functs,is_packed = _get_vectors_information(file_features,ffmodel)
	model 						  = _train_w2v_model(programs)
	while act_index < len(programs):
		test_program    = (_get_program_representation(programs[act_index][0],model),programs[act_index][1])
		train_programs  = [(_get_program_representation(programs[i][0],model),programs[i][1]) for i in xrange(len(programs)) if act_index!=i]
		test_functs     = list(dll_functs[act_index])
		train_functs    = [list(dll_functs[i]) for i in xrange(len(dll_functs)) if act_index!=i]
		is_packed_test  = is_packed[act_index]
		is_packed_train = [is_packed[i] for i in xrange(len(is_packed)) if act_index!=i]
		c_class         = _get_class(test_program[0],train_programs,model,k)
		if   c_class==1 and test_program[1]==1: tp += 1
		elif c_class==1 and test_program[1]==0: fp += 1
		elif c_class==0 and test_program[1]==1: fn += 1
		elif c_class==0 and test_program[1]==0: tn += 1
		act_index += 1
	
	tpr = tp/(tp+fn)
	spc = tn/(tn+fp)
	ppv = tp/(tp+fp)
	npv = tn/(tn+fn)
	fpr = 1.0-spc
	fnr = 1.0-tpr
	fdr = 1.0-ppv
	acc = (tp+tn)/(tp+tn+fp+fn)
	fscore = ((1.0+beta**2)*acc*tpr)/((beta**2)*acc*tpr)
	
	logging.info("Finished leaving one out ")
	logging.info("Results: \n \
				 1) Recall = "+str(tpr)+ "\n \
				 2) True negative rate = "+str(spc)+ "\n \
				 3) Positive predictive value = "+str(ppv)+ "\n \
				 4) Negative predictive value = "+str(npv)+ "\n \
				 5) False positive rate = "+str(fpr)+ "\n \
				 6) False negative rate = "+str(fnr)+ "\n \
				 7) False discovery rate = "+str(fdr)+ "\n \
				 8) Accuracy = "+str(acc)+ "\n \
				 9) F Measure (with beta="+str(beta)+") = "+str(fscore)+"\n")
	
def _serialize(file_name,object): 
	""" Serializa un objeto python en un determinado fichero.

		Almacena en un fichero el contenido del objeto serializado.
    
		Parámetros:
		file_name	-- Ruta del fichero donde almacenar el contenido.
		
		Excepciones:
		A implementar.
    
    """
	with open(file_name,'wb') as fd: dump(object,fd,HIGHEST_PROTOCOL)
	
def _unserialize(file_name):
	""" Deserializar un fichero con contenido serializado.

		Devuelve una lista con el contenido serializado.
    
		Parámetros:
		file_name	-- Ruta del fichero con contenido serializado.
		
		Excepciones:
		A implementar.
    
    """
	res = []
	with open(file_name,'rb') as fd: res.append(load(fd))
	return res
	
def fit(malware_files,non_malware_files,save=True,fprototypes="./train_prototypes.trained",fmodel="./modelw2v.mm",ffunctions="./modelfuncts.mm"): 
	""" Entrena el sistema. Obtiene el modelo word2vec, el modelo de funciones (funciones llamadas por las muestras supervisadas) y
		con ello genera los prototipos.

		Si se indica, almacena en ficheros separados el modelo word2vec, el modelo de funciones y los prototipos, si no
		simplemente los devuelve en una tupla 3-d.
    
		Parámetros:
		train_malware	     -- Ruta donde se encuentran las muestras malware supervisadas.
		train_non_malware    -- Ruta donde se encuentran las muestras no malware supervisadas.
		save			  	 -- Indica si se quieren almacenar los resultados del entrenamiento.
		fprototypes	  	 -- Ruta donde almacenar los prototipos
		fmodel			  	 -- Ruta donde almacenar el modelo word2vec
		ffunctions		  	 -- Ruta donde almacenar el modelo de funciones
		
		Excepciones:
		A implementar.
    
    """
	logging.info("Initializing training with: "+str(len(malware_files)+len(non_malware_files))+" files")
	file_features                 = _extract_train_programs_features(malware_files,non_malware_files)
	func_features				  = _get_all_functs(file_features)
	ffmodel                       =  _get_func_model(file_features,func_features)
	programs,dll_functs,is_packed = _get_vectors_information(file_features,ffmodel)
	model 						  = _train_w2v_model(programs)
	prototypes                    = [(_get_program_representation(programs[i][0],model).tolist()+dll_functs[i]+[is_packed[i]],programs[i][1]) for i in xrange(len(programs))]
	if save==True:
		_serialize(fprototypes,prototypes)
		_serialize(fmodel,model)
		_serialize(ffunctions,func_features)
		logging.info("Saved training results. ")
	else: return (prototypes,model,func_features)
	
def predict(file_name,k,load=True,prototypes=None,model=None,fmodel=None,fprototypes="./train_prototypes.trained",fw2vmodel="./modelw2v.mm",ffmodel="./modelfuncts.mm"):
	""" Clasifica un programa cuya ruta es file_name.

		Devuelve la clasificación del programa: malware o no malware.
    
		Parámetros:
		file_name	  -- Nombre del programa a clasificar
		k             -- Número de vecinos más cercanos.
		load		  -- Indica si se van a cargar los datos de entrenamiento desde fichero o se reciben de la función train.
		prototypes    -- Conjunto de prototipos (muestras supervisadas) obtenidos del entrenamiento.
		model         -- Modelo Word2Vec previamente entrenado.
		fmode		  -- Modelo de funciones (todas las funciones extraidas del conjunto de entrenamiento)
		fprototypes   -- Ruta donde se encuentran los prototipos (muestras supervisadas)
		fw2vmodel	  -- Ruta donde se encuentra el modelo Word2Vec entrenado.
		ffmodel		  -- Ruta donde se encuentra el fichero con todas las funciones llamadas por los prototipos
		
		Excepciones:
		A implementar.
    
    """
	if load==True:
		prototypes = _unserialize(fprototypes)[0]
		model	   = _unserialize(fw2vmodel)[0]
		fmodel	   = list(_unserialize(ffmodel)[0])
	exe_instructions,imports,is_packed = _extract_program_features(file_name)
	file_features = {}
	file_features[file_name] = [(exe_instructions,None),imports,is_packed]
	func_features = _get_func_model(file_features,fmodel)
	exe_instructions,imports,is_packed = _get_vectors_information(file_features,func_features)
	exe_instructions,imports,is_packed = exe_instructions[0][0],imports[0],is_packed
	test_sample = [_get_program_representation(exe_instructions,model).tolist()+imports+is_packed]
	return CLASSES[_get_class(test_sample,prototypes,model,k)]
	
if __name__ == "__main__":
	logging.basicConfig(format='%(asctime)s : %(levelname)s : %(message)s', level=logging.INFO)
	TRAIN_MALWARE_PATH     = "./Train/Malware"
	TRAIN_NON_MALWARE_PATH = "./Train/NoMalware"

	k = 1;
	## TRAINING AND TESTING PROCESS #
	#malware_files                 = _get_files(TRAIN_MALWARE_PATH)
	#non_malware_files             = _get_files(TRAIN_NON_MALWARE_PATH)
	#fit(malware_files,non_malware_files)
	#print predict("./test.exe",1)
	
	## LEAVING ONE OUT TESTING PROCESS ##
	_cross_validation(TRAIN_MALWARE_PATH,TRAIN_NON_MALWARE_PATH,k)
