#!/usr/bin/env python
# -*- coding: utf-8 -*-
from Config import CLASSES
from FeatureExtraction import _extract_train_programs_features
from FeatureExtraction import _get_all_functs
from FeatureExtraction import _get_func_model
from FeatureExtraction import _get_vectors_information
from FeatureExtraction import _train_w2v_model
from FeatureExtraction import _get_program_representation
from Utils import _get_files
from Classifier import _get_class
import logging

	
def _leaving_one_out(train_malware_path,train_non_malware_path,k,beta=1):
	""" Realiza exclusión individual sobre el conjunto de entrenamiento.

		Muestra por pantalla el conjunto de medidas de evaluación del sistema.
    
		Parámetros:
		file_features -- Diccionario con tantas entradas como programas, para cada programa se almacena información (cjto de instrucciones,funciones y medida de empaquetamiento)
		k             -- Número de vecinos más cercanos.
		beta          -- Parámetro beta para calcular la f-medida (1 si se pondera igual la precisión que el recall).
		Excepciones:
		A implementar.
    
    """
	malware_files                     = _get_files(train_malware_path)
	non_malware_files                 = _get_files(train_non_malware_path)
	num_programs					  = len(malware_files)+len(non_malware_files)
	act_index,act_test_sample,err = 0,None,0
	tp,tn,fp,fn,tpr,spc,ppv,npv,fpr,fnr,fdr,acc,fscore = 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
	logging.basicConfig(format='%(asctime)s : %(levelname)s : %(message)s', level=logging.INFO)
	logging.info("Initializing leaving one out with "+str(num_programs)+" programs")
	file_features                 = _extract_train_programs_features(malware_files,non_malware_files)
	name_files					  = [key for key in file_features]
	func_features				  = _get_all_functs(file_features)
	ffmodel                       = _get_func_model(file_features,func_features)
	programs,dll_functs,is_packed = _get_vectors_information(file_features,ffmodel)
	model 						  = _train_w2v_model(programs)
	while act_index < len(programs):
		correct_class   = programs[act_index][1]
		test_program    = _get_program_representation(programs[act_index][0],model)
		test_functs     = list(dll_functs[act_index])
		is_packed_test  = is_packed[act_index] 
		test_program    = [test_program.tolist()+test_functs+[is_packed_test]]
		train_programs  = [ (_get_program_representation(programs[i][0],model).tolist()+list(dll_functs[i])+[is_packed[i]],programs[i][1]) for i in xrange(len(programs)) if act_index!=i]
		logging.info("Testing file "+str(act_index)+" "+name_files[act_index]+" against "+str(len(programs)-1)+" programs")
		c_class         = _get_class(test_program[0],train_programs,model,k)
		logging.info("Computed class = "+str(c_class)+" and correct class is: "+str(correct_class))
		if   c_class==1 and correct_class==1: tp += 1
		elif c_class==1 and correct_class==0: fp += 1
		elif c_class==0 and correct_class==1: fn += 1
		elif c_class==0 and correct_class==0: tn += 1
		act_index += 1
	
	tpr = tp/(tp+fn)
	spc = tn/(tn+fp)
	ppv = tp/(tp+fp)
	npv = tn/(tn+fn)
	fpr = 1.0-spc
	fnr = 1.0-tpr
	fdr = 1.0-ppv
	acc = (tp+tn)/(tp+tn+fp+fn)
	fscore = ((1.0+beta**2)*acc*tpr)/((beta**2)*acc*tpr)
	
	"""
	logging.info("Finished leaving one out ")
	logging.info("Results: \n \
				 1) Recall = "+str(tpr)+ "\n \
				 2) True negative rate = "+str(spc)+ "\n \
				 3) Positive predictive value = "+str(ppv)+ "\n \
				 4) Negative predictive value = "+str(npv)+ "\n \
				 5) False positive rate = "+str(fpr)+ "\n \
				 6) False negative rate = "+str(fnr)+ "\n \
				 7) False discovery rate = "+str(fdr)+ "\n \
				 8) Accuracy = "+str(acc)+ "\n \
				 9) F Measure (with beta="+str(beta)+") = "+str(fscore)+"\n")
	"""
	result = "Results: \n \
				 1) Recall = "+str(tpr)+ "\n \
				 2) True negative rate = "+str(spc)+ "\n \
				 3) Positive predictive value = "+str(ppv)+ "\n \
				 4) Negative predictive value = "+str(npv)+ "\n \
				 5) False positive rate = "+str(fpr)+ "\n \
				 6) False negative rate = "+str(fnr)+ "\n \
				 7) False discovery rate = "+str(fdr)+ "\n \
				 8) Accuracy = "+str(acc)+ "\n \
				 9) F Measure (with beta="+str(beta)+") = "+str(fscore)+"\n"
	return result
				 
def cross_validation_b_blocks(train_malware_path,train_non_malware_path,k,beta=1,b=10): pass
def _hold_out(train_malware_path,train_non_malware_path,k,percent_malware=0.5,percent_non_malware=0.5): pass
def resubstitution(train_malware_path,train_non_malware_path): pass
