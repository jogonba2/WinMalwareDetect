#!/usr/bin/env python
# -*- coding: utf-8 -*-
from gensim.models import Word2Vec
from Config import CLASSES,W2V_MIN_COUNT,W2V_SIZE,W2V_WINDOW
from ExecutablePreprocess import _get_instructions
from ExecutablePreprocess import _get_imports
from ExecutablePreprocess import _is_packed
from pefile import PE
import logging

def _extract_program_features(file_name):
	""" Extrae la información de un programa dado

		La información que se extrae actualmente son el conjunto de instrucciones, las funciones y una medida de empaquetamiento

		Parámetros:
		file_name      		   -- Ruta del programa

		Excepciones:
		A implementar
    """
    
	pe                     = PE(file_name)
	exe_instructions,imports,is_packed       = _get_instructions(pe),set(_get_imports(pe)),_is_packed(pe)
	return exe_instructions,imports,is_packed
	
def _extract_train_programs_features(malware_files,non_malware_files):
	""" Obtiene la información de las muestras de entrenamiento (prototipos) 

		La información que se extrae actualmente son el conjunto de instrucciones, las funciones y una medida de empaquetamiento
		Devuelve un diccionario {nombreDePrograma:[(instrucciones,clase),(funciones),(medidaEmpaquetamiento)],...}
		

		Parámetros:
		malware_files       		   -- Directorio donde se encuentran las muestras de entrenamiento malware.
		non_malware_files 			   -- Directorio donde se encuentran las muestras de entrenamiento no malware.

		Excepciones:
		A implementar
    """
	logging.basicConfig(format='%(asctime)s : %(levelname)s : %(message)s', level=logging.INFO)
	file_features           = {}
	i = 0
	for non_malware_file in non_malware_files:
		logging.info("Extracting information from file "+str(i)+" : "+non_malware_file)
		exe_instructions,imports,is_packed = _extract_program_features(non_malware_file)
		file_features[non_malware_file] = [(exe_instructions,0),imports,is_packed]
		i += 1
	
	for malware_file in malware_files:
		logging.info("Extracting information from file "+str(i)+" : "+malware_file)
		exe_instructions,imports,is_packed = _extract_program_features(malware_file)
		file_features[malware_file] = [(exe_instructions,1),imports,is_packed]
		i += 1
		
	logging.info("Instructions and functions extracted from all programs and detected if they're packed")
	
	return file_features
	
def _get_program_representation(p,model):
	""" Genera la representación vectorial de las instrucciones del programa p en base al modelo w2v previamente entrenado

		Devuelve la representación vectorial de las instrucciones del programa p.
		Se define la representación vectorial de un conjunto de instrucciones como la suma de las representaciones
		vectoriales de cada instrucción del conjunto (suma de semánticas)

		Parámetros:
		p       		   -- Conjunto de instrucciones del programa p.
		model 			   -- Modelo word2vec ya entrenado.

		Excepciones:
		A implementar
    """
	try:     res = 0 + model[p[0]]
	except:  res = 0
	for i in xrange(1,len(p)):
		try: 	res += model[p[i]]
		except: res += 0
	return res

def _train_w2v_model(corpus_programs): 
	""" Entrena un modelo word2vec sobre el conjunto de instrucciones de los programas

		Devuelve el modelo entrenado.
    
		Parámetros:
		corpus_programs -- Conjunto de tuplas con las instrucciones de los programas y sus categorias (instrucciones,categoria)

		Excepciones:
		A implementar.
    
    """
	return Word2Vec([program for (program,cat) in corpus_programs],min_count=MIN_COUNT,size=SIZE,window=WINDOW)

def _get_all_functs(file_features):
	""" Obtiene el conjunto de funciones de todos los programas.

		Devuelve el conjunto de funciones
    
		Parámetros:
		file_features -- Diccionario con información para cada programa.

		Excepciones:
		A implementar.
    
    """
	func_features = set()
	for fd in file_features: func_features = func_features.union(file_features[fd][1])
	return func_features

def _get_func_model(file_features,func_features):
	""" Genera para cada programa un vector BOW sobre sus funciones: 1 si tiene una llamada a una función f, 0 si no
		
		Devuelve el conjunto de vectores BOW de todos los programas.
	
		Parámetros:
		file_features -- Diccionario con tantas entradas como programas, para cada programa se almacena información (cjto de instrucciones,funciones y medida de empaquetamiento)

		Excepciones:
		A implementar.   
    """
	res = []

	for fd in file_features:
		fd_features = []
		for feature in func_features:
			if feature in file_features[fd][1]: fd_features.append(1)
			else:								fd_features.append(0)
		res.append(fd_features)
		
	return res
	
def _get_vectors_information(file_features,ffmodel):
	""" Genera N vectores con el conjunto P de programas , F de funciones y otra información
		
		Devuelve los N vectores con información sobre todo el conjunto de prototipos. 
	
		Parámetros:
		file_features -- Diccionario con tantas entradas como programas, para cada programa se almacena información (cjto de instrucciones,funciones y medida de empaquetamiento)
		func_features -- Conjunto de funciones presentes en el corpus de entrenamiento
		Excepciones:
		A implementar.   
    """
	programs,dll_functs,is_packed           = [],[],[]
	keys = file_features.keys()
	for i in xrange(len(keys)):
		feature = keys[i]
		programs.append(file_features[feature][0])
		dll_functs.append(ffmodel[i])
		is_packed.append(file_features[feature][2])
	return programs,dll_functs,is_packed
